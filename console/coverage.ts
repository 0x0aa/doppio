// Generated by CoffeeScript 1.6.2
(function() {
  var BootstrapClassLoader, RuntimeState, argv, fs, jvm, native_stats, natives, op_stats, opcodes, optimist, path, print, print_unused, print_usage, run_tests, setup_native_stats, setup_opcode_stats, testing,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  jvm = require('../src/jvm');

  opcodes = require('../src/opcodes');

  RuntimeState = require('../src/runtime').RuntimeState;

  BootstrapClassLoader = require('../src/ClassLoader').BootstrapClassLoader;

  natives = require('../src/natives');

  testing = require('../src/testing');

  setup_opcode_stats = function() {
    var num, old_fn, op, op_stats, _ref;

    op_stats = {};
    _ref = opcodes.opcodes;
    for (num in _ref) {
      op = _ref[num];
      op_stats[op.name] = 0;
      old_fn = op.execute;
      op.execute = (function(old_fn) {
        return function(rs) {
          op_stats[this.name]++;
          return old_fn.call(this, rs);
        };
      })(old_fn);
    }
    return op_stats;
  };

  setup_native_stats = function() {
    var func, native_stats, sig, _ref, _ref1;

    native_stats = {};
    _ref = natives.native_methods;
    for (sig in _ref) {
      func = _ref[sig];
      native_stats[sig] = 0;
      natives.native_methods[sig] = (function(func, sig) {
        return function() {
          var args;

          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          native_stats[sig]++;
          return func.apply(null, args);
        };
      })(func, sig);
    }
    _ref1 = natives.trapped_methods;
    for (sig in _ref1) {
      func = _ref1[sig];
      native_stats[sig] = 0;
      natives.trapped_methods[sig] = (function(func, sig) {
        return function() {
          var args;

          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          native_stats[sig]++;
          return func.apply(null, args);
        };
      })(func, sig);
    }
    return native_stats;
  };

  print_usage = function(stats) {
    var count, name, names, _i, _len, _results;

    names = (function() {
      var _results;

      _results = [];
      for (name in stats) {
        count = stats[name];
        _results.push(name);
      }
      return _results;
    })();
    names.sort(function(a, b) {
      return stats[b] - stats[a];
    });
    _results = [];
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      _results.push(console.log(stats[name], name));
    }
    return _results;
  };

  print_unused = function(stats, stats_name) {
    var count, name, unused_count;

    unused_count = 0;
    for (name in stats) {
      count = stats[name];
      if (!(count === 0)) {
        continue;
      }
      unused_count++;
      console.log(name);
    }
    if (unused_count > 0) {
      return console.log("" + unused_count + " " + stats_name + " have yet to be tested.");
    }
  };

  run_tests = function(test_classes, stdout, quiet, callback) {
    var doppio_dir, jcl_dir, tc, _runner;

    doppio_dir = typeof node !== "undefined" && node !== null ? '/home/doppio/' : path.resolve(__dirname, '..');
    if ((test_classes != null ? test_classes.length : void 0) > 0) {
      test_classes = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = test_classes.length; _i < _len; _i++) {
          tc = test_classes[_i];
          _results.push(tc.replace(/\.class$/, ''));
        }
        return _results;
      })();
    } else {
      test_classes = testing.find_test_classes(doppio_dir);
    }
    jcl_dir = path.resolve(doppio_dir, 'vendor/classes');
    jvm.set_classpath(jcl_dir, doppio_dir);
    _runner = function() {
      var rs, test;

      if (test_classes.length === 0) {
        return callback();
      }
      test = test_classes.shift();
      quiet || stdout("running " + test + "...\n");
      rs = new RuntimeState((function() {}), (function() {}), new BootstrapClassLoader(jvm.read_classfile));
      return jvm.run_class(rs, test, [], _runner);
    };
    return _runner();
  };

  if (require.main === module) {
    print = require('util').print;
    optimist = require('optimist').boolean(['n', 'o', 'q', 'h']).alias({
      n: 'natives',
      o: 'opcodes',
      q: 'quiet',
      p: 'print-usage',
      h: 'help'
    }).describe({
      n: 'Cover native functions',
      o: 'Cover opcodes',
      q: 'Suppress in-progress output',
      p: 'Print all usages, not just unused',
      h: 'Show usage'
    }).usage('Usage: $0 [class_file(s)]');
    argv = optimist.argv;
    if (argv.help) {
      return optimist.showHelp();
    }
    if (!(argv.opcodes || argv.natives)) {
      console.error('Must select natives, opcodes, or both');
      return optimist.showHelp();
    }
    if (argv.opcodes) {
      op_stats = setup_opcode_stats();
    }
    if (argv.natives) {
      native_stats = setup_native_stats();
    }
    run_tests(argv._, print, argv.quiet, function() {
      if (argv['print-usage'] != null) {
        if (argv.opcodes) {
          print_usage(op_stats);
        }
        if (argv.natives) {
          return print_usage(native_stats);
        }
      } else {
        if (argv.opcodes) {
          print_unused(op_stats, 'opcodes');
        }
        if (argv.natives) {
          return print_unused(native_stats, 'native methods');
        }
      }
    });
  }

}).call(this);
