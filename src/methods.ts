// Generated by CoffeeScript 1.6.2
(function() {
  "use strict";
  var AbstractMethodField, JavaArray, JavaObject, ReturnException, attributes, debug_vars, jvm, logging, native_methods, natives, opcodes, root, runtime, thread_name, trace, trapped_methods, util, vtrace, _, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('../vendor/_.js');

  util = require('./util');

  opcodes = require('./opcodes');

  attributes = require('./attributes');

  natives = require('./natives');

  runtime = require('./runtime');

  logging = require('./logging');

  jvm = require('./jvm');

  vtrace = logging.vtrace, trace = logging.trace, debug_vars = logging.debug_vars;

  ReturnException = require('./exceptions').ReturnException;

  native_methods = natives.native_methods, trapped_methods = natives.trapped_methods;

  _ref = require('./java_object'), JavaArray = _ref.JavaArray, JavaObject = _ref.JavaObject, thread_name = _ref.thread_name;

  root = typeof exports !== "undefined" && exports !== null ? exports : this.methods = {};

  AbstractMethodField = (function() {
    function AbstractMethodField(cls) {
      this.cls = cls;
    }

    AbstractMethodField.prototype.parse = function(bytes_array, constant_pool, idx) {
      this.idx = idx;
      this.access_byte = bytes_array.get_uint(2);
      this.access_flags = util.parse_flags(this.access_byte);
      this.name = constant_pool.get(bytes_array.get_uint(2)).value;
      this.raw_descriptor = constant_pool.get(bytes_array.get_uint(2)).value;
      this.parse_descriptor(this.raw_descriptor);
      return this.attrs = attributes.make_attributes(bytes_array, constant_pool);
    };

    AbstractMethodField.prototype.get_attribute = function(name) {
      var attr, _i, _len, _ref1;

      _ref1 = this.attrs;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        attr = _ref1[_i];
        if (attr.name === name) {
          return attr;
        }
      }
      return null;
    };

    AbstractMethodField.prototype.get_attributes = function(name) {
      var attr, _i, _len, _ref1, _results;

      _ref1 = this.attrs;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        attr = _ref1[_i];
        if (attr.name === name) {
          _results.push(attr);
        }
      }
      return _results;
    };

    return AbstractMethodField;

  })();

  root.Field = (function(_super) {
    __extends(Field, _super);

    function Field() {
      _ref1 = Field.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Field.prototype.parse_descriptor = function(raw_descriptor) {
      return this.type = raw_descriptor;
    };

    Field.prototype.reflector = function(rs, success_fn, failure_fn) {
      var clazz_obj, create_obj, sig, _ref2,
        _this = this;

      sig = (_ref2 = _.find(this.attrs, function(a) {
        return a.name === "Signature";
      })) != null ? _ref2.sig : void 0;
      create_obj = function(clazz_obj, type_obj) {
        return new JavaObject(rs, rs.get_bs_class('Ljava/lang/reflect/Field;'), {
          'Ljava/lang/reflect/Field;clazz': clazz_obj,
          'Ljava/lang/reflect/Field;name': rs.init_string(_this.name, true),
          'Ljava/lang/reflect/Field;type': type_obj,
          'Ljava/lang/reflect/Field;modifiers': _this.access_byte,
          'Ljava/lang/reflect/Field;slot': _this.idx,
          'Ljava/lang/reflect/Field;signature': sig != null ? rs.init_string(sig) : null
        });
      };
      clazz_obj = this.cls.get_class_object(rs);
      this.cls.loader.resolve_class(rs, this.type, (function(type_cls) {
        var rv, type_obj;

        type_obj = type_cls.get_class_object(rs);
        rv = create_obj(clazz_obj, type_obj);
        return success_fn(rv);
      }), failure_fn);
    };

    return Field;

  })(AbstractMethodField);

  root.Method = (function(_super) {
    __extends(Method, _super);

    function Method() {
      _ref2 = Method.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Method.prototype.parse_descriptor = function(raw_descriptor) {
      var field, p, param_carr, param_str, return_str, __, _i, _len, _ref3, _ref4;

      this.reset_caches = false;
      _ref3 = /\(([^)]*)\)(.*)/.exec(raw_descriptor), __ = _ref3[0], param_str = _ref3[1], return_str = _ref3[2];
      param_carr = param_str.split('');
      this.param_types = ((function() {
        var _results;

        _results = [];
        while ((field = util.carr2descriptor(param_carr))) {
          _results.push(field);
        }
        return _results;
      })());
      this.param_bytes = 0;
      _ref4 = this.param_types;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        p = _ref4[_i];
        this.param_bytes += p === 'D' || p === 'J' ? 2 : 1;
      }
      if (!this.access_flags["static"]) {
        this.param_bytes++;
      }
      this.num_args = this.param_types.length;
      if (!this.access_flags["static"]) {
        this.num_args++;
      }
      return this.return_type = return_str;
    };

    Method.prototype.full_signature = function() {
      return "" + (this.cls.get_type()) + "::" + this.name + this.raw_descriptor;
    };

    Method.prototype.parse = function(bytes_array, constant_pool, idx) {
      var c, sig;

      Method.__super__.parse.call(this, bytes_array, constant_pool, idx);
      sig = this.full_signature();
      if ((c = trapped_methods[sig]) != null) {
        this.code = c;
        return this.access_flags["native"] = true;
      } else if (this.access_flags["native"]) {
        if ((c = native_methods[sig]) != null) {
          return this.code = c;
        } else if (sig.indexOf('::registerNatives()V', 1) < 0 && sig.indexOf('::initIDs()V', 1) < 0) {
          if (jvm.show_NYI_natives) {
            console.log(sig);
          }
          return this.code = function(rs) {
            return rs.java_throw(rs.get_bs_class('Ljava/lang/UnsatisfiedLinkError;'), "Native method '" + sig + "' not implemented.\nPlease fix or file a bug at https://github.com/int3/doppio/issues");
          };
        } else {
          return this.code = null;
        }
      } else {
        this.has_bytecode = true;
        return this.code = _.find(this.attrs, function(a) {
          return a.name === 'Code';
        });
      }
    };

    Method.prototype.reflector = function(rs, is_constructor, success_fn, failure_fn) {
      var adefs, anns, clazz_obj, exceptions, obj, sig, typestr, _ref3, _ref4, _ref5, _ref6, _ref7,
        _this = this;

      if (is_constructor == null) {
        is_constructor = false;
      }
      typestr = is_constructor ? 'Ljava/lang/reflect/Constructor;' : 'Ljava/lang/reflect/Method;';
      exceptions = (_ref3 = (_ref4 = _.find(this.attrs, function(a) {
        return a.name === 'Exceptions';
      })) != null ? _ref4.exceptions : void 0) != null ? _ref3 : [];
      anns = (_ref5 = _.find(this.attrs, function(a) {
        return a.name === 'RuntimeVisibleAnnotations';
      })) != null ? _ref5.raw_bytes : void 0;
      adefs = (_ref6 = _.find(this.attrs, function(a) {
        return a.name === 'AnnotationDefault';
      })) != null ? _ref6.raw_bytes : void 0;
      sig = (_ref7 = _.find(this.attrs, function(a) {
        return a.name === 'Signature';
      })) != null ? _ref7.sig : void 0;
      obj = {};
      clazz_obj = this.cls.get_class_object(rs);
      return this.cls.loader.resolve_class(rs, this.return_type, (function(rt_cls) {
        var etype_objs, fetch_catch_type, fetch_etype, fetch_ptype, handlers, i, j, k, param_type_objs, rt_obj, _ref8;

        rt_obj = rt_cls.get_class_object(rs);
        j = -1;
        etype_objs = [];
        i = -1;
        param_type_objs = [];
        k = 0;
        if ((((_ref8 = _this.code) != null ? _ref8.exception_handlers : void 0) != null) && _this.code.exception_handlers.length > 0) {
          handlers = [
            {
              catch_type: 'Ljava/lang/Throwable;'
            }
          ];
          Array.prototype.push.apply(handlers, _this.code.exception_handlers);
        } else {
          handlers = [];
        }
        fetch_catch_type = function() {
          var eh;

          if (k < handlers.length) {
            eh = handlers[k++];
            if (eh.catch_type === '<any>') {
              return fetch_catch_type();
            }
            return _this.cls.loader.resolve_class(rs, eh.catch_type, fetch_catch_type, failure_fn);
          } else {
            return fetch_ptype();
          }
        };
        fetch_etype = function() {
          var e_desc;

          j++;
          if (j < exceptions.length) {
            e_desc = exceptions[j];
            return _this.cls.loader.resolve_class(rs, e_desc, (function(cls) {
              etype_objs[j] = cls.get_class_object(rs);
              return fetch_etype();
            }), failure_fn);
          } else {
            obj[typestr + 'clazz'] = clazz_obj;
            obj[typestr + 'name'] = rs.init_string(_this.name, true);
            obj[typestr + 'parameterTypes'] = new JavaArray(rs, rs.get_bs_class('[Ljava/lang/Class;'), param_type_objs);
            obj[typestr + 'returnType'] = rt_obj;
            obj[typestr + 'exceptionTypes'] = new JavaArray(rs, rs.get_bs_class('[Ljava/lang/Class;'), etype_objs);
            obj[typestr + 'modifiers'] = _this.access_byte;
            obj[typestr + 'slot'] = _this.idx;
            obj[typestr + 'signature'] = sig != null ? rs.init_string(sig) : null;
            obj[typestr + 'annotations'] = anns != null ? new JavaArray(rs, rs.get_bs_class('[B'), anns) : null;
            obj[typestr + 'annotationDefault'] = adefs != null ? new JavaArray(rs, rs.get_bs_class('[B'), adefs) : null;
            return success_fn(new JavaObject(rs, rs.get_bs_class(typestr), obj));
          }
        };
        fetch_ptype = function() {
          i++;
          if (i < _this.param_types.length) {
            return _this.cls.loader.resolve_class(rs, _this.param_types[i], (function(cls) {
              param_type_objs[i] = cls.get_class_object(rs);
              return fetch_ptype();
            }), failure_fn);
          } else {
            return fetch_etype();
          }
        };
        return fetch_catch_type();
      }), failure_fn);
    };

    Method.prototype.take_params = function(caller_stack) {
      var params, start;

      start = caller_stack.length - this.param_bytes;
      params = caller_stack.slice(start);
      caller_stack.length -= this.param_bytes;
      return params;
    };

    Method.prototype.convert_params = function(rs, params) {
      var converted_params, p, param_idx, _i, _len, _ref3;

      converted_params = [rs];
      param_idx = 0;
      if (!this.access_flags["static"]) {
        converted_params.push(params[0]);
        param_idx = 1;
      }
      _ref3 = this.param_types;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        converted_params.push(params[param_idx]);
        param_idx += (p === 'J' || p === 'D') ? 2 : 1;
      }
      return converted_params;
    };

    Method.prototype.run_manually = function(func, rs, converted_params) {
      var e, ret_type, rv;

      trace("entering native method " + (this.full_signature()));
      try {
        rv = func.apply(null, converted_params);
      } catch (_error) {
        e = _error;
        if (e === ReturnException) {
          return;
        }
        throw e;
      }
      rs.meta_stack().pop();
      ret_type = this.return_type;
      if (ret_type !== 'V') {
        if (ret_type === 'Z') {
          rs.push(rv + 0);
        } else {
          rs.push(rv);
        }
        if (ret_type === 'J' || ret_type === 'D') {
          return rs.push(null);
        }
      }
    };

    Method.prototype.initialize = function() {
      return this.reset_caches = true;
    };

    Method.prototype.method_lock = function(rs) {
      if (this.access_flags["static"]) {
        return this.cls.get_class_object(rs);
      } else {
        return rs.cl(0);
      }
    };

    Method.prototype.run_bytecode = function(rs) {
      var annotation, cf, code, depth, instr, op, pc, _i, _len, _ref3, _ref4;

      trace("entering method " + (this.full_signature()));
      if (this.reset_caches && (((_ref3 = this.code) != null ? _ref3.opcodes : void 0) != null)) {
        _ref4 = this.code.opcodes;
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          instr = _ref4[_i];
          if (instr != null) {
            instr.reset_cache();
          }
        }
      }
      code = this.code.opcodes;
      cf = rs.curr_frame();
      if (this.access_flags.synchronized && cf.pc === 0) {
        if (!opcodes.monitorenter(rs, this.method_lock(rs))) {
          cf.pc = 0;
          return;
        }
      }
      op = code[cf.pc];
      while (true) {
        if (!((typeof RELEASE !== "undefined" && RELEASE !== null) || logging.log_level < logging.STRACE)) {
          pc = cf.pc;
          if (!op) {
            throw "" + this.name + ":" + pc + " => (null)";
          }
          annotation = op.annotate(pc, this.cls.constant_pool);
        }
        if (op.execute(rs) === false) {
          break;
        }
        if (!((typeof RELEASE !== "undefined" && RELEASE !== null) || logging.log_level < logging.STRACE)) {
          vtrace(("" + (this.cls.get_type()) + "::" + this.name + ":" + pc + " => " + op.name) + annotation);
          depth = rs.meta_stack().length();
          vtrace("D: " + depth + ", S: [" + (debug_vars(cf.stack)) + "], L: [" + (debug_vars(cf.locals)) + "], T: " + (rs.curr_thread.get_field != null ? thread_name(rs, rs.curr_thread) : void 0));
        }
        cf.pc += 1 + op.byte_count;
        op = code[cf.pc];
      }
    };

    Method.prototype.setup_stack = function(runtime_state) {
      var c, c_params, caller_stack, i, ms, params, sf, _ref3,
        _this = this;

      ms = runtime_state.meta_stack();
      caller_stack = runtime_state.curr_frame().stack;
      params = this.take_params(caller_stack);
      if (this.access_flags["native"]) {
        if (this.code != null) {
          ms.push(sf = new runtime.StackFrame(this, [], []));
          c_params = this.convert_params(runtime_state, params);
          sf.runner = function() {
            return _this.run_manually(_this.code, runtime_state, c_params);
          };
          return sf;
        }
        return;
      }
      if (this.access_flags.abstract) {
        runtime_state.java_throw(runtime_state.get_bs_class('Ljava/lang/Error;'), "called abstract method: " + (this.full_signature()));
      }
      ms.push(sf = new runtime.StackFrame(this, params, []));
      if (this.code.run_stamp < runtime_state.run_stamp) {
        this.code.run_stamp = runtime_state.run_stamp;
        this.code.parse_code();
        if (this.access_flags.synchronized) {
          _ref3 = this.code.opcodes;
          for (i in _ref3) {
            c = _ref3[i];
            if (c.name.match(/^[ildfa]?return$/)) {
              (function(c) {
                return c.execute = function(rs) {
                  opcodes.monitorexit(rs, _this.method_lock(rs));
                  return c.orig_execute(rs);
                };
              })(c);
            }
          }
        }
      }
      sf.runner = function() {
        return _this.run_bytecode(runtime_state);
      };
      return sf;
    };

    return Method;

  })(AbstractMethodField);

}).call(this);
